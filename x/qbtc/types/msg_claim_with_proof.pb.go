// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qbtc/qbtc/v1/msg_claim_with_proof.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UTXORef identifies a specific UTXO by its transaction ID and output index.
type UTXORef struct {
	// The Bitcoin transaction ID where this UTXO originates
	Txid string `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	// The output index in the Bitcoin transaction
	Vout uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
}

func (m *UTXORef) Reset()         { *m = UTXORef{} }
func (m *UTXORef) String() string { return proto.CompactTextString(m) }
func (*UTXORef) ProtoMessage()    {}
func (*UTXORef) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf71fdfb6b1ac5fe, []int{0}
}
func (m *UTXORef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UTXORef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UTXORef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UTXORef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UTXORef.Merge(m, src)
}
func (m *UTXORef) XXX_Size() int {
	return m.Size()
}
func (m *UTXORef) XXX_DiscardUnknown() {
	xxx_messageInfo_UTXORef.DiscardUnknown(m)
}

var xxx_messageInfo_UTXORef proto.InternalMessageInfo

func (m *UTXORef) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *UTXORef) GetVout() uint32 {
	if m != nil {
		return m.Vout
	}
	return 0
}

// MsgClaimWithProof is the message for claiming one or more UTXOs using a ZK proof.
// The user proves ownership of a Bitcoin address without revealing their private key.
// All UTXOs must belong to the same Bitcoin address (the one proven in the ZK proof).
// Maximum 50 UTXOs can be claimed in a single batch to prevent DoS.
type MsgClaimWithProof struct {
	// The address on the qbtc chain that will receive the claimed tokens
	Claimer string `protobuf:"bytes,1,opt,name=claimer,proto3" json:"claimer,omitempty"`
	// The UTXOs to claim. All must belong to the same Bitcoin address.
	// Maximum 50 UTXOs per batch.
	Utxos []UTXORef `protobuf:"bytes,2,rep,name=utxos,proto3" json:"utxos"`
	// The ZK proof proving ownership of the Bitcoin address that controls these UTXOs
	Proof ZKProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof"`
}

func (m *MsgClaimWithProof) Reset()         { *m = MsgClaimWithProof{} }
func (m *MsgClaimWithProof) String() string { return proto.CompactTextString(m) }
func (*MsgClaimWithProof) ProtoMessage()    {}
func (*MsgClaimWithProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf71fdfb6b1ac5fe, []int{1}
}
func (m *MsgClaimWithProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimWithProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimWithProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimWithProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimWithProof.Merge(m, src)
}
func (m *MsgClaimWithProof) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimWithProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimWithProof.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimWithProof proto.InternalMessageInfo

func (m *MsgClaimWithProof) GetClaimer() string {
	if m != nil {
		return m.Claimer
	}
	return ""
}

func (m *MsgClaimWithProof) GetUtxos() []UTXORef {
	if m != nil {
		return m.Utxos
	}
	return nil
}

func (m *MsgClaimWithProof) GetProof() ZKProof {
	if m != nil {
		return m.Proof
	}
	return ZKProof{}
}

// MsgClaimWithProofResponse is the response for a successful batch claim.
type MsgClaimWithProofResponse struct {
	// The total amount of tokens claimed across all UTXOs
	TotalAmountClaimed uint64 `protobuf:"varint,1,opt,name=total_amount_claimed,json=totalAmountClaimed,proto3" json:"total_amount_claimed,omitempty"`
	// The number of UTXOs successfully claimed
	UtxosClaimed uint32 `protobuf:"varint,2,opt,name=utxos_claimed,json=utxosClaimed,proto3" json:"utxos_claimed,omitempty"`
}

func (m *MsgClaimWithProofResponse) Reset()         { *m = MsgClaimWithProofResponse{} }
func (m *MsgClaimWithProofResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimWithProofResponse) ProtoMessage()    {}
func (*MsgClaimWithProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf71fdfb6b1ac5fe, []int{2}
}
func (m *MsgClaimWithProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimWithProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimWithProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimWithProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimWithProofResponse.Merge(m, src)
}
func (m *MsgClaimWithProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimWithProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimWithProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimWithProofResponse proto.InternalMessageInfo

func (m *MsgClaimWithProofResponse) GetTotalAmountClaimed() uint64 {
	if m != nil {
		return m.TotalAmountClaimed
	}
	return 0
}

func (m *MsgClaimWithProofResponse) GetUtxosClaimed() uint32 {
	if m != nil {
		return m.UtxosClaimed
	}
	return 0
}

func init() {
	proto.RegisterType((*UTXORef)(nil), "qbtc.qbtc.v1.UTXORef")
	proto.RegisterType((*MsgClaimWithProof)(nil), "qbtc.qbtc.v1.MsgClaimWithProof")
	proto.RegisterType((*MsgClaimWithProofResponse)(nil), "qbtc.qbtc.v1.MsgClaimWithProofResponse")
}

func init() {
	proto.RegisterFile("qbtc/qbtc/v1/msg_claim_with_proof.proto", fileDescriptor_bf71fdfb6b1ac5fe)
}

var fileDescriptor_bf71fdfb6b1ac5fe = []byte{
	// 390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x51, 0x4f, 0xaf, 0xd2, 0x40,
	0x10, 0xef, 0x02, 0x4a, 0x5c, 0xe1, 0xc0, 0x06, 0xb5, 0x72, 0x28, 0x0d, 0xc6, 0x40, 0x48, 0x6c,
	0xad, 0xde, 0xbc, 0x18, 0xe1, 0x68, 0x8c, 0xa6, 0xd1, 0x68, 0xb8, 0x34, 0x6d, 0x29, 0xa5, 0x09,
	0x65, 0x4a, 0x77, 0x8b, 0x78, 0xf5, 0xe8, 0xc9, 0x8f, 0xc2, 0x07, 0xf0, 0x03, 0x70, 0xe4, 0xe8,
	0xe9, 0xe5, 0x05, 0x0e, 0x7c, 0x8d, 0x97, 0x9d, 0x2d, 0x2f, 0xef, 0x85, 0xcb, 0xec, 0xec, 0xcc,
	0x6f, 0xfe, 0xfc, 0xe6, 0x47, 0xfb, 0xab, 0x40, 0x84, 0x36, 0x9a, 0xb5, 0x63, 0xa7, 0x3c, 0xf6,
	0xc2, 0x85, 0x9f, 0xa4, 0xde, 0xcf, 0x44, 0xcc, 0xbd, 0x2c, 0x07, 0x98, 0x59, 0x59, 0x0e, 0x02,
	0x58, 0x43, 0x62, 0x2c, 0x34, 0x6b, 0xa7, 0xd3, 0xf2, 0xd3, 0x64, 0x09, 0x36, 0x5a, 0x05, 0xe8,
	0x3c, 0x0b, 0x81, 0xa7, 0xc0, 0x65, 0x8f, 0xb2, 0x55, 0x99, 0x68, 0xc7, 0x10, 0x03, 0xba, 0xb6,
	0xf4, 0xca, 0x68, 0xf7, 0xde, 0x60, 0xf1, 0x2b, 0x8b, 0x3c, 0x3f, 0xc9, 0xa7, 0x39, 0x64, 0x0a,
	0xd0, 0x73, 0x68, 0xfd, 0xdb, 0xd7, 0x1f, 0x9f, 0xdd, 0x68, 0xc6, 0x18, 0xad, 0x89, 0x4d, 0x32,
	0xd5, 0x89, 0x49, 0x06, 0x8f, 0x5c, 0xf4, 0x65, 0x6c, 0x0d, 0x85, 0xd0, 0x2b, 0x26, 0x19, 0x34,
	0x5d, 0xf4, 0x7b, 0xff, 0x08, 0x6d, 0x7d, 0xe2, 0xf1, 0x58, 0x32, 0xf8, 0x9e, 0x88, 0xf9, 0x17,
	0xb9, 0x3f, 0xd3, 0x69, 0x1d, 0x39, 0x45, 0x79, 0xd9, 0xe0, 0xfc, 0x65, 0x0e, 0x7d, 0x50, 0x88,
	0x0d, 0x70, 0xbd, 0x62, 0x56, 0x07, 0x8f, 0xdf, 0x3c, 0xb1, 0xee, 0x72, 0xb4, 0xca, 0xe9, 0xa3,
	0xda, 0xee, 0xaa, 0xab, 0xb9, 0x0a, 0x29, 0x4b, 0xf0, 0x2a, 0x7a, 0xd5, 0x24, 0x97, 0x25, 0x93,
	0x8f, 0x38, 0xf2, 0x5c, 0x82, 0xc8, 0x77, 0xfd, 0xdf, 0xa7, 0xed, 0xf0, 0x3c, 0xf3, 0xcf, 0x69,
	0x3b, 0x7c, 0x8a, 0xac, 0x2f, 0x16, 0xed, 0xe5, 0xf4, 0xf9, 0x45, 0xd0, 0x8d, 0x78, 0x06, 0x4b,
	0x1e, 0xb1, 0xd7, 0xb4, 0x2d, 0x40, 0xf8, 0x0b, 0xcf, 0x4f, 0xa1, 0x58, 0x0a, 0x25, 0x53, 0xa4,
	0x6e, 0x52, 0x73, 0x19, 0xe6, 0x3e, 0x60, 0x6a, 0xac, 0x32, 0xec, 0x05, 0x6d, 0xe2, 0xce, 0xb7,
	0x50, 0x75, 0xaa, 0x06, 0x06, 0x4b, 0xd0, 0xe8, 0xfd, 0xee, 0x60, 0x90, 0xfd, 0xc1, 0x20, 0xd7,
	0x07, 0x83, 0xfc, 0x3d, 0x1a, 0xda, 0xfe, 0x68, 0x68, 0xff, 0x8f, 0x86, 0x36, 0x79, 0x19, 0x27,
	0x62, 0x5e, 0x04, 0x56, 0x08, 0xa9, 0x1d, 0x88, 0x70, 0xf5, 0x0a, 0xf2, 0x58, 0xe9, 0xb5, 0x51,
	0x8f, 0xd4, 0x8c, 0x07, 0x0f, 0x51, 0xad, 0xb7, 0x37, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe2, 0x53,
	0x0c, 0x9e, 0x49, 0x02, 0x00, 0x00,
}

func (m *UTXORef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UTXORef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UTXORef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vout != 0 {
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(m.Vout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimWithProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimWithProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimWithProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Utxos) > 0 {
		for iNdEx := len(m.Utxos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Utxos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Claimer) > 0 {
		i -= len(m.Claimer)
		copy(dAtA[i:], m.Claimer)
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(len(m.Claimer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimWithProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimWithProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimWithProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UtxosClaimed != 0 {
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(m.UtxosClaimed))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalAmountClaimed != 0 {
		i = encodeVarintMsgClaimWithProof(dAtA, i, uint64(m.TotalAmountClaimed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgClaimWithProof(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgClaimWithProof(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UTXORef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovMsgClaimWithProof(uint64(l))
	}
	if m.Vout != 0 {
		n += 1 + sovMsgClaimWithProof(uint64(m.Vout))
	}
	return n
}

func (m *MsgClaimWithProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Claimer)
	if l > 0 {
		n += 1 + l + sovMsgClaimWithProof(uint64(l))
	}
	if len(m.Utxos) > 0 {
		for _, e := range m.Utxos {
			l = e.Size()
			n += 1 + l + sovMsgClaimWithProof(uint64(l))
		}
	}
	l = m.Proof.Size()
	n += 1 + l + sovMsgClaimWithProof(uint64(l))
	return n
}

func (m *MsgClaimWithProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalAmountClaimed != 0 {
		n += 1 + sovMsgClaimWithProof(uint64(m.TotalAmountClaimed))
	}
	if m.UtxosClaimed != 0 {
		n += 1 + sovMsgClaimWithProof(uint64(m.UtxosClaimed))
	}
	return n
}

func sovMsgClaimWithProof(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgClaimWithProof(x uint64) (n int) {
	return sovMsgClaimWithProof(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UTXORef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgClaimWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UTXORef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UTXORef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vout", wireType)
			}
			m.Vout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgClaimWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimWithProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgClaimWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimWithProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimWithProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claimer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Utxos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Utxos = append(m.Utxos, UTXORef{})
			if err := m.Utxos[len(m.Utxos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgClaimWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimWithProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgClaimWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimWithProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimWithProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountClaimed", wireType)
			}
			m.TotalAmountClaimed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmountClaimed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtxosClaimed", wireType)
			}
			m.UtxosClaimed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtxosClaimed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgClaimWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgClaimWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgClaimWithProof(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgClaimWithProof
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgClaimWithProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgClaimWithProof
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgClaimWithProof
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgClaimWithProof
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgClaimWithProof        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgClaimWithProof          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgClaimWithProof = fmt.Errorf("proto: unexpected end of group")
)
